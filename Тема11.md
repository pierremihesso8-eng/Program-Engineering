# Тема 11 : Итераторы и генераторы

**Студент:** Джи Киянаге Исуру Анупама Викрамасингхе

**Группа:** ИВТ-23-1

## Таблица выполнения заданий

| № задания 11 | Лабораторная работа | Самостоятельнаяработа |
|-----------|------------| -----------|
| 1 | + | + |
| 2 | + |+ |
| 3 | + |+ |
| 4 | + |+ |
| 5 | + |+ |

# Лабораторная работа :  11

## Задание 1: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 1" src="https://github.com/user-attachments/assets/9c9c782d-6cec-4e01-aa15-ef3d06ca794b" />

**Вывод:** Генераторы списков создают полноценные списки, которые можно многократно итерировать

## Задание 2: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 2" src="https://github.com/user-attachments/assets/634893dc-be4c-4bcf-af7c-6b95f675df25" />

**Вывод:** Выражения-генераторы создают объекты-генераторы, которые можно использовать только один раз

## Задание 3: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 3" src="https://github.com/user-attachments/assets/1139cf2e-2687-4a05-97b8-6fafc16bbcdb" />

**Вывод:** Функции-генераторы с yield позволяют создавать кастомные итераторы с сохранением состояния

## Задание 4: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 4" src="https://github.com/user-attachments/assets/81ff91f5-2db8-4467-8e46-25c78ce8bd45" />

**Вывод:** Разница между списками и генераторами - списки хранят все данные в памяти, а генераторы создают элементы "на лету"

## Задание 5: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 5" src="https://github.com/user-attachments/assets/53d775a5-1e6e-4fd6-a9c3-da07d880d5d1" />

**Вывод:** Итераторы могут быть созданы разными способами, но все они следуют протоколу итерации


# Самостоятельная работа :  11

## Задание 1: 

**Код:**
```python
def fib(n):
    a, b = 1, 1
    count = 0
    while count < n:
        yield a
        a, b = b, a + b
        count += 1

fib_gen = fib(200)
result = None
for i, num in enumerate(fib_gen, 1):
    if i == 200:
        result = num
        print(f"200-е число Фибоначчи: {num}")
```

**Скриншот результата:**
<img width="1366" height="768" alt="self 1" src="https://github.com/user-attachments/assets/38522981-8e25-4243-b072-cf46c8f5c6f6" />

**Вывод:** Научился создавать эффективные генераторы для работы с большими последовательностями. Генератор Фибоначчи использует yield для экономии памяти.

## Задание 2: 

**Код:**
```python
def fib_with_save(n, filename="fib.txt"):
    a, b = 1, 1
    count = 0
    with open(filename, 'w', encoding='utf-8') as file:
        while count < n:
            file.write(f"{a}\n")
            yield a
            a, b = b, a + b
            count += 1

fib_saver = fib_with_save(20, "fib.txt")
for num in fib_saver:
    print(f"Сгенерировано: {num}")
```

**Скриншот результата:**
<img width="1366" height="768" alt="self 2" src="https://github.com/user-attachments/assets/521c6067-9ada-4eed-87f2-8b1c93d7dad0" />

**Вывод:**  Освоил комбинирование генераторов с работой с файлами. Каждое число записывается сразу при генерации, что оптимально для больших данных.

## Задание 3: 

**Код:**
```python
a = [i ** 2 for i in range(1, 5)]

print('a - ', a)
for i in a:
    print(i)

print('iter(a) - ', iter(a))
for i in a:
    print(i)
```

**Скриншот результата:**
<img width="1366" height="768" alt="self 3" src="https://github.com/user-attachments/assets/16eb9f16-0a66-42c2-a705-b7d5cc654420" />

**Вывод:** Генераторы списков создают полноценные коллекции в памяти, подходят для многократного использования.

## Задание 4: 

**Код:**
```python
b = (i ** 2 for i in range(1, 5))
print(b)
print('first')
for i in b:
    print(i)
print('second')
for i in b:
    print(i)
```

**Скриншот результата:**
<img width="1366" height="768" alt="self 4" src="https://github.com/user-attachments/assets/60b0032e-f9ff-414a-86e4-b55e768c05cd" />

**Вывод:** Выражения-генераторы экономят память, но могут быть использованы только один раз.

## Задание 5: 

**Код:**
```python
def countdown(count):
    while count >= 0:
        yield count
        count -= 1

counter = countdown(5)
for i in counter:
    print(i)
```

**Скриншот результата:**
<img width="1366" height="768" alt="self 5" src="https://github.com/user-attachments/assets/b2dc4258-4a64-48a8-86cf-748fb369e368" />

**Вывод:** Функции с yield сохраняют состояние между вызовами, идеальны для сложных итерационных процессов.
