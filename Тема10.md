# Тема 10 : Декораторы и исключения

**Студент:** Джи Киянаге Исуру Анупама Викрамасингхе

**Группа:** ИВТ-23-1

## Таблица выполнения заданий

| № задания 10 | Лабораторная работа | Самостоятельнаяработа |
|-----------|------------| -----------|
| 1 | + | + |
| 2 | + |+ |
| 3 | + |+ |
| 4 | + |+ |
| 5 | + |+ |

# Лабораторная работа :  10

## Задание 1: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 1" src="https://github.com/user-attachments/assets/d89c61ad-7484-4ce3-83d5-b11f78061736" />

**Вывод:** Изучил практическое применение декоратора @lru_cache для оптимизации рекурсивных вычислений. На примере чисел Фибоначчи убедился, что мемоизация промежуточных результатов может ускорить выполнение программы в тысячи раз. Это демонстрирует важность кэширования для ресурсоемких операций.


## Задание 2: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 2" src="https://github.com/user-attachments/assets/45a2b80a-94e9-4925-852e-5340682b1060" />

**Вывод:** Освоил создание пользовательских декораторов для валидации данных. Научился разрабатывать декораторы, которые проверяют входные параметры функций без изменения их исходного кода. Это полезно для добавления сквозной функциональности в приложения.


## Задание 3: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 3" src="https://github.com/user-attachments/assets/4d1364ea-4b0d-4ee8-b30f-94d4a1e4cf2d" />

**Вывод:** Понял важность обработки исключений в веб-приложениях. Научился использовать конструкцию try/except/finally для graceful error handling, что предотвращает аварийное завершение программы при некорректных входных данных.


## Задание 4: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 4" src="https://github.com/user-attachments/assets/6c71f4b9-44d9-4198-b6bf-c994996905e6" />

**Вывод:** Научился создавать собственные классы исключений для специфических бизнес-правил приложения. Это позволяет делать код более читаемым и точно обрабатывать конкретные ошибки предметной области.


## Задание 5: 

**Скриншот результата:** 
<img width="1366" height="768" alt="lab 5" src="https://github.com/user-attachments/assets/b9fbffd1-30f5-4bb2-b90f-16b693957b26" />

**Вывод:** Изучил создание декораторов через классы с использованием магических методов ___init___ и ___call___. Понял, что такой подход полезен для сложных декораторов с состоянием и дополнительной логикой инициализации.


# Самостоятельная работа :  10

## Задание 1: 

**Код:**
```python
import time

def timer_decorator(func):
    def wrapper():
        start_time = time.time()
        result = func()
        end_time = time.time()
        print(f"\nВремя выполнения программы: {end_time - start_time:.6f} секунд")
        return result
    return wrapper

@timer_decorator
def fibonacci():
    fib1 = fib2 = 1
    print("Числа Фибоначчи:")
    print(fib1, fib2, end=' ')
    
    for i in range(2, 200):
        fib1, fib2 = fib2, fib1 + fib2
        print(fib2, end=' ')

if __name__ == '__main__':
    fibonacci()
```

**Скриншот результата:**
<img width="1366" height="768" alt="self 1" src="https://github.com/user-attachments/assets/2b32e13c-e50f-4d6c-9964-e42398678289" />

**Вывод:** Научился создавать декораторы для измерения времени выполнения функций. Убедился, что итеративное решение чисел Фибоначчи выполняется очень быстро (менее 0.01 секунды для 200 чисел), в отличие от рекурсивного подхода. Декораторы позволяют легко добавлять функциональность измерения производительности без изменения исходного кода функций.

## Задание 2: 

**Код:**
```python
class EmptyFileError(Exception):
    pass

def read_file_safe(filename):
    try:
        with open(filename, 'r', encoding='utf-8') as file:
            content = file.read()
            if not content.strip():  # Проверяем, не пустой ли файл
                raise EmptyFileError("файл пустой")
            print(f"Содержимое файла '{filename}':")
            print(content)
    except FileNotFoundError:
        print(f"Ошибка: Файл '{filename}' не найден")
    except EmptyFileError as e:
        print(f"Ошибка: {e}")
    except Exception as e:
        print(f"Произошла ошибка: {e}")

# Тестирование
print("=== Тест с пустым файлом ===")
read_file_safe("empty_file.txt")

print("\n=== Тест с файлом с данными ===")
read_file_safe("data_file.txt")

print("\n=== Тест с несуществующим файлом ===")
read_file_safe("nonexistent_file.txt")
```

**Скриншот результата:**
<img width="1366" height="768" alt="self 2" src="https://github.com/user-attachments/assets/bb63c34f-913e-4450-866a-899f222d9fbd" />

**Вывод:** Освоил работу с файлами и обработку исключений при операциях ввода-вывода. Научился создавать собственные исключения для специфических ситуаций (пустой файл) и правильно обрабатывать стандартные исключения (FileNotFoundError). Это важно для создания надежных программ, которые корректно работают с внешними ресурсами.


## Задание 3: 

**Код:**
```python
def add_two():
    try:
        user_input = input("Введите число для сложения с 2: ")
        number = float(user_input)  # Пробуем преобразовать в число
        result = 2 + number
        print(f"Результат: 2 + {number} = {result}")
        return result
    except ValueError:
        print("Ошибка: Неподходящий тип данных. Ожидалось число.")
        return None

# Тестирование
print("=== Тест 1: Корректный ввод ===")
add_two()

print("\n=== Тест 2: Ввод строки ===")
add_two()

print("\n=== Тест 3: Ввод дробного числа ===")
add_two()
```

**Скриншот результата:**
<img width="1366" height="768" alt="self 3" src="https://github.com/user-attachments/assets/1bc08a51-bf93-406c-94e2-013f161f20b2" />

**Вывод:** Научился использовать блок try/except для обработки ошибок преобразования типов данных. Исключение ValueError возникает при попытке преобразовать неподходящую строку в число. Такой подход позволяет создавать устойчивые к ошибкам пользовательского ввода программы и предоставлять понятные сообщения об ошибках.


## Задание 4: 

**Код:**
```python
class RetryDecorator:
    """
    Декоратор для повторного выполнения функции в случае возникновения исключений
    """
    def __init__(self, max_attempts=3):
        self.max_attempts = max_attempts
    
    def __call__(self, func):
        def wrapper(*args, **kwargs):
            for attempt in range(1, self.max_attempts + 1):
                try:
                    print(f"Попытка {attempt} из {self.max_attempts}")
                    result = func(*args, **kwargs)
                    print("Функция выполнена успешно!")
                    return result
                except Exception as e:
                    print(f"Ошибка при выполнении: {e}")
                    if attempt == self.max_attempts:
                        print("Достигнуто максимальное количество попыток")
                        raise
                    print("Повторная попытка...")
        return wrapper

# Первая функция - симуляция ненадежного соединения
@RetryDecorator(max_attempts=3)
def unstable_connection():
    import random
    if random.random() < 0.7:  # 70% вероятность ошибки
        raise ConnectionError("Потеряно соединение с сервером")
    return "Данные успешно получены"

# Вторая функция - деление с возможной ошибкой
@RetryDecorator(max_attempts=2)
def safe_division(a, b):
    if b == 0:
        raise ValueError("Деление на ноль невозможно")
    return a / b

print("=== Тест декоратора повтора ===")
print("1. Тест нестабильного соединения:")
try:
    result = unstable_connection()
    print(f"Результат: {result}")
except Exception as e:
    print(f"Итоговая ошибка: {e}")

print("\n2. Тест безопасного деления:")
try:
    result = safe_division(10, 0)
    print(f"Результат деления: {result}")
except Exception as e:
    print(f"Итоговая ошибка: {e}")

print("\n3. Тест успешного деления:")
try:
    result = safe_division(10, 2)
    print(f"Результат деления: {result}")
except Exception as e:
    print(f"Итоговая ошибка: {e}")
```

**Скриншот результата:**
<img width="1366" height="768" alt="self 4" src="https://github.com/user-attachments/assets/05260ecb-e6c3-4221-b150-d477cf2670a4" />

**Вывод:** Создал собственный декоратор для повторного выполнения функций при возникновении ошибок. Этот подход полезен для работы с ненадежными операциями (сетевые запросы, операции с базами данных). Декоратор автоматически повторяет выполнение функции заданное количество раз, что повышает надежность программы без усложнения основной логики.


## Задание 5: 

**Код:**
```python
class InsufficientFundsError(Exception):
    """Исключение для случая недостаточных средств на счете"""
    def __init__(self, balance, amount):
        self.balance = balance
        self.amount = amount
        super().__init__(f"Недостаточно средств. Баланс: {balance}, требуется: {amount}")

class InvalidAgeError(Exception):
    """Исключение для недопустимого возраста"""
    def __init__(self, age, min_age):
        self.age = age
        self.min_age = min_age
        super().__init__(f"Возраст {age} недопустим. Минимальный возраст: {min_age}")

# Первое использование - банковский счет
class BankAccount:
    def __init__(self, balance=0):
        self.balance = balance
    
    def withdraw(self, amount):
        if amount > self.balance:
            raise InsufficientFundsError(self.balance, amount)
        self.balance -= amount
        print(f"Снято {amount}. Остаток на счете: {self.balance}")
        return amount

# Второе использование - проверка возраста
def check_age_restriction(age, min_age=18):
    if age < min_age:
        raise InvalidAgeError(age, min_age)
    print(f"Возраст {age} допустим. Доступ разрешен.")

print("=== Тест пользовательских исключений ===")

print("1. Тест банковского счета:")
account = BankAccount(1000)
try:
    account.withdraw(500)
    account.withdraw(800)  # Должно вызвать исключение
except InsufficientFundsError as e:
    print(f"Ошибка банковской операции: {e}")

print("\n2. Тест проверки возраста:")
try:
    check_age_restriction(20)
    check_age_restriction(15)  # Должно вызвать исключение
except InvalidAgeError as e:
    print(f"Ошибка проверки возраста: {e}")

print("\n3. Тест с разным минимальным возрастом:")
try:
    check_age_restriction(16, 21)  # Должно вызвать исключение
except InvalidAgeError as e:
    print(f"Ошибка проверки возраста: {e}")
```

**Скриншот результата:** 
<img width="1366" height="768" alt="self 5" src="https://github.com/user-attachments/assets/10bc92d1-4e5a-428a-a96a-dd8f16233dcd" />


**Вывод:** Научился создавать собственные исключения для конкретных предметных областей. Пользовательские исключения делают код более читаемым и позволяют точно описывать специфические ошибки бизнес-логики. Это особенно полезно в крупных проектах, где стандартных исключений недостаточно для описания всех возможных ошибок предметной области.

